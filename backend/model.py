# -*- coding: utf-8 -*-
"""Many Diseases.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rGaTA5tPxvYr6Ptm5Pl3_ZkfSwgY7Umq
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as T
from torchvision.models import mobilenet_v2
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader
from sklearn.model_selection import train_test_split
import os
from torchvision.io import read_image

# Define global mean and standard deviation constants used for normalization
means = [0.485, 0.456, 0.406]
stds = [0.229, 0.224, 0.225]

# Define training data augmentation and normalization transformations
transform_train = T.Compose([
    T.Resize((224, 224)),
    T.RandomHorizontalFlip(),
    T.RandomRotation(degrees=60),
    T.ToTensor(),
    T.Normalize(means, stds),
])

# Define validation data normalization transformation
transform_val = T.Compose([
    T.Resize((224, 224)),
    T.ToTensor(),
    T.Normalize(means, stds),
])



import torch
from torch.utils.data import Dataset
from torchvision.io import read_image

import os
import pandas as pd
from torch.utils.data import Dataset
from torchvision.io import read_image

import os
import pandas as pd
from torch.utils.data import Dataset
from PIL import Image  # Use PIL to load images

import os
import pandas as pd
from torch.utils.data import Dataset
from PIL import Image  # Use PIL to load images

import os
import pandas as pd
from torch.utils.data import Dataset
from torchvision.io import read_image
from PIL import Image
import torch

import os
import pandas as pd
from torch.utils.data import Dataset
from torchvision.io import read_image
from PIL import Image
import torch

# Load your CSV file
csv_file = '/Users/aromaatieno/Downloads/Capstone Project App/data_science/DDI Dataset /ddi_metadata.csv'
data = pd.read_csv(csv_file)

# Extract unique disease labels from the 'disease' column
unique_disease_labels = data['disease'].unique()

# Create a mapping of disease names to indices
disease_to_index = {label: index for index, label in enumerate(unique_disease_labels)}

class CustomDataset(Dataset):
    def __init__(self, root, csv_path=None, download=True, transform=None):
        if csv_path is None:
            csv_path = os.path.join(root, "ddi_metadata.csv")
        if not os.path.exists(csv_path) and download:
            raise Exception("Please provide a download link to obtain the DDI dataset.")
        assert os.path.exists(csv_path), f"Path not found <{csv_path}>."

        self.root = root
        self.transform = transform

        # Load metadata from the CSV file
        self.annotations = pd.read_csv(csv_path)

        # Construct a list of image paths and their associated metadata, including disease
        self.imgs = [(os.path.join(self.root, row['DDI_file']), int(row['malignant']), row['skin_tone'], row['disease'])
                     for _, row in self.annotations.iterrows()]

    def __len__(self):
        return len(self.imgs)

    def __getitem__(self, index):
        img_path, _, _, disease_name = self.imgs[index]
        img = Image.open(img_path).convert('RGB')
        if self.transform:
            img = self.transform(img)
        disease_index = disease_to_index[disease_name]
        return img, disease_index, disease_name




# Create a custom dataset instance
custom_dataset = CustomDataset(root='/Users/aromaatieno/Downloads/Capstone Project App/data_science/DDI Dataset ', transform=transform_train)

# Get the number of classes (unique diseases)
num_classes = len(unique_disease_labels)



# Get the indices for the train and validation sets
indices = list(range(len(custom_dataset)))
train_indices, val_indices = train_test_split(indices, test_size=0.2, random_state=42)



# Create data loaders for training and validation sets
batch_size = 32  # Adjust as needed
train_loader = DataLoader(torch.utils.data.Subset(custom_dataset, train_indices), batch_size=batch_size, shuffle=True)
val_loader = DataLoader(torch.utils.data.Subset(custom_dataset, val_indices), batch_size=batch_size, shuffle=False)  # No need to shuffle the validation set

# Load a pre-trained MobileNetV2 model and modify the output layer for your classification task
model = mobilenet_v2(pretrained=True)


# Replace the last classification layer with a new one
model.classifier[1] = nn.Linear(model.classifier[1].in_features, num_classes)


# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)  # Adjust learning rate as needed

# Training loop
num_epochs = 10  # Adjust the number of training epochs as needed

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0

    for inputs, labels, _ in train_loader:  # Add `_` to ignore the third value (disease names)
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    print(f'Epoch [{epoch + 1}/{num_epochs}] Training Loss: {running_loss / len(train_loader)}')

    # Validation step
    model.eval()
    val_loss = 0.0
    correct = 0
    total = 0

    with torch.no_grad():
        for inputs, labels, _ in val_loader:  # Add `_` to ignore the third value (disease names)
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    val_accuracy = 100 * correct / total
    print(f'Epoch [{epoch + 1}/{num_epochs}] Validation Loss: {val_loss / len(val_loader)}')
    print(f'Epoch [{epoch + 1}/{num_epochs}] Validation Accuracy: {val_accuracy}%')

print('Finished Training')

# Save the trained model to a file within your Colab workspace
model_save_path = '/Users/aromaatieno/Downloads/Capstone Project App/backend/DDI_model.pth'  # Change the path as needed
torch.save(model.state_dict(), model_save_path)

import torch
import torchvision.transforms as T
from PIL import Image

# Load the trained model (you can adjust the path)
model_path = '/Users/aromaatieno/Downloads/Capstone Project App/backend/DDI_model.pth'  # Change the path to your saved model
model = mobilenet_v2(pretrained=False)  # Create an instance of the model
model.classifier[1] = nn.Linear(model.classifier[1].in_features, num_classes)  # Replace with your model's configuration
model.load_state_dict(torch.load(model_path))
model.eval()  # Set the model to evaluation mode

# Define the transformation for input images
transform = T.Compose([
    T.Resize((224, 224)),
    T.ToTensor(),
    T.Normalize(means, stds),  # Use the same mean and std as during training
])

# Function to make predictions
def predict_image(image_path, model, transform):
    # Open and preprocess the image
    img = Image.open(image_path).convert("RGB")
    img = transform(img).unsqueeze(0)  # Add batch dimension

    # Make a prediction
    with torch.no_grad():
        output = model(img)
        _, predicted_class = output.max(1)

    return predicted_class.item()  # Return the predicted class index

# Provide the path to the image you want to predict
image_path = '/Users/aromaatieno/Downloads/Capstone Project App/data_science/DDI Dataset /000001.png'  # Change to the path of your image

# Get the prediction
predicted_class = predict_image(image_path, model, transform)

# Map the predicted class index back to disease name
index_to_disease = {index: disease for disease, index in disease_to_index.items()}
predicted_disease = index_to_disease[predicted_class]

print(f"The predicted disease is: {predicted_disease}")


# Add this function to model.py

def get_model(num_classes):
    # Load a pre-trained MobileNetV2 model and modify the output layer for your classification task
    model = mobilenet_v2(pretrained=False)
    # Replace the last classification layer with a new one that matches the number of classes
    model.classifier[1] = nn.Linear(model.classifier[1].in_features, num_classes)
    return model
